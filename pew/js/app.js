// Generated by CoffeeScript 1.12.7
var camTween, closeDifficulty, closeDockingBay, closeHallOfFame, closeLeaderboard, closeMenu, config, engine, nextShip, openDifficulty, openDockingBay, openHallOfFame, openLeaderboard, openMenu, prevShip, setDifficulty, submitScore;

config = Config.get();

config.fillWindow();

HighScoreManager.auth('pewpew', 'pewpew', true);

HighScoreManager.getScore = function(which, daysInPast) {
  var d, hsm, json, zz;
  hsm = this.get();
  hsm._ensureTokenPresence();
  json = {
    api_key: hsm.apiKey,
    secret: hsm.secret,
    type: 'highscore',
    __limit: 3,
    __sort: {
      score: 'desc',
      created_at: 'desc'
    }
  };
  if (daysInPast != null) {
    d = new Date();
    d.setSeconds(0);
    d.setMinutes(0);
    d.setHours(0);
    d.setDate(d.getDate() - daysInPast);
    zz = parseInt(d.getTime() / 1000);
    json.created_at = {
      '$gt': zz
    };
  }
  return jNorthPole.getStorage(json, function(data) {
    var i, item, len, s;
    s = '';
    for (i = 0, len = data.length; i < len; i++) {
      item = data[i];
      s += "<div><span class='entryName'>" + item.name + "</span><span class='entrySeparator'></span><span class='entryScore'>" + item.score + "</span></div>";
    }
    return window[which].innerHTML = s;
  }, hsm.errorHandler);
};

Utils.FADE_COLOR = '#0f0f0f';

Config.defaultDifficulty = 0;

Config.defaultPlayerName = 'Pilot';

Config.mapTop = 10;

Config.mapLeft = 4;

Config.mapBottom = -8;

Config.weapons = [Bullet, Laser, Bomb];

Config.enemies = [FlyingPunch, Truck, StaticNature, FlyingStaticWall, SmallEnemy];

Config.buffs = [BaseBuff];

Config.backgrounds = ['space-1', 'space-2', 'space-4', 'space-6'];

Config.defaultShip = 'pew-bat';

Config.defaultHighSpeed = 1;

Config.defaultLowSpeed = 0.25;

Config.defaultPlayerSpeed = 8;

Config.defaultWeapon = 0;

Config.defaultShotDelay = 0.5;

Config.defaultEnemyDelay = 1;

Config.defaultBuffDelay = 5;

Config.defaultTerrainSpeed = 4;

Config.minTicker = 0.1;

Config.defaultMinTicker = 0.1;

Config.defaultMaxTicker = 2;

Config.maxEnemyDelay = 4;

Config.maxNameLength = 7;

Config.scoreY = 2;

Config.scoreExtraY = 0;

Config.createBonus = 1;

Config.maxStaticNature = 10;

Config.storage = {
  prefix: 'pew',
  playerName: 'playerName',
  highScorePlayerName: 'highScorePlayerName',
  highScore: 'highScore',
  defaultShip: 'defaultShip',
  difficulty: 'difficulty'
};

setDifficulty = function(difficulty, closeMenu) {
  var normalSpeed;
  if (closeMenu == null) {
    closeMenu = false;
  }
  console.log("Setting difficulty " + difficulty);
  normalSpeed = function() {
    Config.defaultLowSpeed = 0.25;
    Config.defaultPlayerSpeed = 8;
    Config.defaultShotDelay = 0.5;
    Config.defaultEnemyDelay = 1;
    Config.defaultBuffDelay = 5;
    return Config.defaultWeapon = 0;
  };
  switch (difficulty) {
    case 0:
      normalSpeed();
      break;
    case 1:
      Config.defaultLowSpeed = 0.5;
      Config.defaultPlayerSpeed = 11;
      Config.defaultShotDelay = 0.4;
      Config.defaultEnemyDelay = 0.8;
      Config.defaultBuffDelay = 4;
      Config.defaultWeapon = 1;
      break;
    case 2:
      Config.defaultLowSpeed = 1;
      Config.defaultPlayerSpeed = 15;
      Config.defaultShotDelay = 0.2;
      Config.defaultEnemyDelay = 0.5;
      Config.defaultBuffDelay = 2;
      Config.defaultWeapon = 2;
      break;
    default:
      normalSpeed();
  }
  Config.defaultHighSpeed = Config.defaultLowSpeed + 0.75;
  if (closeMenu) {
    Persist.set(Config.storage.difficulty, difficulty);
    return closeDifficulty();
  }
};

Persist.PREFIX = Config.storage.prefix;

Persist["default"](Config.storage.playerName, Config.defaultPlayerName);

Persist["default"](Config.storage.highScorePlayerName, Config.defaultPlayerName);

Persist["default"](Config.storage.defaultShip, Config.defaultShip);

Persist["default"](Config.storage.difficulty, Config.defaultDifficulty);

Persist.setDefaultShip = function(name) {
  return Persist.set(Config.storage.defaultShip, name);
};

Persist.getDefaultShip = function() {
  return Persist.get(Config.storage.defaultShip);
};

Persist.getPlayerName = function() {
  return Persist.get(Config.storage.playerName);
};

Persist.setPlayerName = function(name) {
  return Persist.set(Config.storage.playerName, name);
};

Persist.getHighScorePlayerName = function() {
  return Persist.get(Config.storage.highScorePlayerName);
};

Persist.setHighScorePlayerName = function(name) {
  return Persist.set(Config.storage.highScorePlayerName, name);
};

Persist.getLocalHighScore = function() {
  var highScore;
  highScore = Persist.get(Config.storage.highScore);
  if (highScore === 'undefined' || (highScore == null)) {
    highScore = 0;
  }
  return parseInt(highScore);
};

Persist.setHighScore = function(score) {
  return Persist.set(Config.storage.highScore, score);
};

submitScore = function() {
  var name, scene;
  scene = SceneManager.currentScene();
  name = window.scorePlayerNameInput.value || Persist.getPlayerName();
  name = name.replace(/[^a-zA-Z0-9]/g, "").substr(0, Config.maxNameLength);
  Persist.setPlayerName(name);
  if (scene.level.score > scene.level.highScore) {
    Persist.setHighScore(scene.level.score);
    Persist.setHighScorePlayerName(name);
    scene.level.highScore = scene.level.score;
    scene.level._updateHighScoreUI();
  }
  HighScoreManager.addScore(name, scene.level.score);
  window.addScorePage.style.display = 'none';
  return scene.level.delayedStart();
};

closeMenu = function() {
  var scene;
  scene = SceneManager.currentScene();
  scene.level.setMenuVisible(true);
  scene.chicken.targetOpacity = 1;
  window["menuPage"].style.display = 'none';
  return window.score.style.visibility = 'visible';
};

openMenu = function() {
  var scene;
  scene = SceneManager.currentScene();
  scene.level.setMenuVisible(false);
  scene.chicken.targetOpacity = 0;
  window.score.style.visibility = 'hidden';
  return window.menuPage.style.display = 'flex';
};

openLeaderboard = function() {
  HighScoreManager.getScore('highScore7Days', 6);
  HighScoreManager.getScore('highScoreToday', 0);
  window.menuPage.style.display = 'none';
  return window.leaderboardPage.style.display = 'flex';
};

closeLeaderboard = function() {
  window.menuPage.style.display = 'flex';
  return window.leaderboardPage.style.display = 'none';
};

openHallOfFame = function() {
  HighScoreManager.getScore('highScoreAllTime');
  window.menuPage.style.display = 'none';
  return window.hallOfFamePage.style.display = 'flex';
};

closeHallOfFame = function() {
  window.menuPage.style.display = 'flex';
  return window.hallOfFamePage.style.display = 'none';
};

openDifficulty = function() {
  window.menuPage.style.display = 'none';
  return window.difficultyPage.style.display = 'flex';
};

closeDifficulty = function() {
  window.menuPage.style.display = 'flex';
  return window.difficultyPage.style.display = 'none';
};

camTween = void 0;

openDockingBay = function() {
  if (camTween != null) {
    camTween.stop();
  }
  window.menuPage.style.display = 'none';
  window.dockingBayPage.style.display = 'flex';
  SceneManager.currentScene().chicken.targetOpacity = 1;
  camTween = Helper.tween({
    mesh: engine.camera,
    target: {
      x: 0,
      y: 5,
      z: -5
    },
    kind: 'Cubic',
    direction: 'Out',
    duration: 1000
  });
  return camTween.start();
};

closeDockingBay = function() {
  if (camTween != null) {
    camTween.stop();
  }
  window.menuPage.style.display = 'flex';
  window.dockingBayPage.style.display = 'none';
  SceneManager.currentScene().chicken.targetOpacity = 0;
  camTween = Helper.tween({
    mesh: engine.camera,
    target: {
      x: 0,
      y: 20,
      z: -3
    },
    kind: 'Cubic',
    direction: 'Out',
    duration: 1000
  });
  return camTween.start();
};

prevShip = function() {
  return SceneManager.currentScene().chicken.prevModel();
};

nextShip = function() {
  return SceneManager.currentScene().chicken.nextModel();
};

document.addEventListener("visibilitychange", function(event) {
  var menuPageVisible;
  menuPageVisible = window.addScorePage.style.display === 'flex' || window.menuPage.style.display === 'flex' || window.hallOfFamePage.style.display === 'flex' || window.dockingBayPage.style.display === 'flex' || window.leaderboardPage.style.display === 'flex' || window.difficultyPage.style.display === 'flex' || window.start.style.visibility === 'visible';
  if (document.hidden && !menuPageVisible) {
    return SceneManager.currentScene().level.stop();
  }
}, false);

engine = new Engine3D();

engine.setClearColor(Utils.FADE_COLOR);

Engine3D.scenify(engine, function() {
  var buffTicker, buffType, chicken, directionalLight, enemyTicker, enemyType, i, input, j, k, len, len1, len2, level, pointer, ref, ref1, ref2, replay, scene, shaker, shootTicker, terrain, weapon;
  scene = SceneManager.currentScene();
  input = window.scorePlayerNameInput.onkeyup = function(event) {
    var name;
    name = window.scorePlayerNameInput.value;
    if (name.size() > Config.maxNameLength) {
      name = name.substr(0, Config.maxNameLength);
    }
    return window.scorePlayerNameInput.value = name;
  };
  chicken = new Player();
  chicken.setStartPosition();
  scene.chicken = chicken;
  scene.scene.add(chicken.mesh);
  pointer = new Pointer();
  scene.pointer = pointer;
  scene.scene.add(pointer.mesh);
  terrain = new Terrain();
  scene.terrain = terrain;
  scene.scene.add(terrain.mesh);
  scene.scene.add(Helper.ambientLight());
  directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(0.0, 0.0, -1.0);
  scene.scene.add(directionalLight);
  directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(0.0, 1.0, -1.0);
  scene.scene.add(directionalLight);
  directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(1.0, 0.0, 1.0);
  scene.scene.add(directionalLight);
  directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(-1.0, 0.0, 1.0);
  scene.scene.add(directionalLight);
  shootTicker = new ShootTicker();
  scene.shootTicker = shootTicker;
  enemyTicker = new EnemyTicker();
  scene.enemyTicker = enemyTicker;
  buffTicker = new BuffTicker();
  scene.buffTicker = buffTicker;
  level = new Level();
  scene.level = level;
  replay = new Replay();
  scene.replay = replay;
  ref = Config.enemies;
  for (i = 0, len = ref.length; i < len; i++) {
    enemyType = ref[i];
    PoolManager.onSpawn(enemyType, function(enemy, options) {
      enemy.setStartPosition();
      if (enemy instanceof SmallEnemy && !replay.replaying) {
        enemy.mesh.position.copy(options.src.mesh.position);
      }
      return scene.scene.add(enemy.mesh);
    });
    PoolManager.onRelease(enemyType, function(enemy, options) {
      var explosion;
      if ((options.skipExplosion == null) || options.skipExplosion === false) {
        explosion = PoolManager.spawn(Explosion);
        explosion.mesh.position.copy(enemy.mesh.position);
      }
      return scene.scene.remove(enemy.mesh);
    });
  }
  ref1 = Config.buffs;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    buffType = ref1[j];
    PoolManager.onSpawn(buffType, function(buff, options) {
      buff.setStartPosition();
      return scene.scene.add(buff.mesh);
    });
    PoolManager.onRelease(buffType, function(buff, options) {
      if ((options.keepBonus == null) || options.keepBonus === false) {
        Config.createBonus = 1;
      }
      return scene.scene.remove(buff.mesh);
    });
  }
  PoolManager.onSpawn(Explosion, function(explosion, options) {
    explosion.resetCubes();
    scene.scene.add(explosion.mesh);
    if (options.src != null) {
      explosion.mesh.position.x = options.src.mesh.position.x;
      explosion.mesh.position.y = options.src.mesh.position.y;
      return explosion.mesh.position.z = options.src.mesh.position.z;
    }
  });
  PoolManager.onRelease(Explosion, function(explosion) {
    return scene.scene.remove(explosion.mesh);
  });
  PoolManager.onSpawn(Text, function(text, options) {
    if (!replay.replaying) {
      text.fromJson(options);
    }
    return scene.scene.add(text.mesh);
  });
  PoolManager.onRelease(Text, function(text) {
    return scene.scene.remove(text.mesh);
  });
  ref2 = Config.weapons;
  for (k = 0, len2 = ref2.length; k < len2; k++) {
    weapon = ref2[k];
    PoolManager.onSpawn(weapon, function(bullet, options) {
      if (!replay.replaying) {
        bullet.mesh.position.copy(options.src.mesh.position);
        bullet.mesh.rotation.set(options.src.mesh.rotation.x, options.src.mesh.rotation.y, options.src.mesh.rotation.z);
        if (options.offsetX != null) {
          bullet.mesh.position.x += options.offsetX;
        }
        if (options.offsetZ != null) {
          bullet.mesh.position.z += options.offsetZ;
        }
        if (options.rY != null) {
          bullet.mesh.rotation.y += options.rY;
        }
      }
      return scene.scene.add(bullet.mesh);
    });
    PoolManager.onRelease(weapon, function(bullet) {
      return scene.scene.remove(bullet.mesh);
    });
  }
  PoolManager.spawn(Explosion, {
    src: {
      mesh: {
        position: {
          x: -2,
          y: 0,
          z: 0
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        }
      }
    }
  });
  PoolManager.spawn(Explosion, {
    src: {
      mesh: {
        position: {
          x: 0,
          y: 0,
          z: 0
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        }
      }
    }
  });
  PoolManager.spawn(Explosion, {
    src: {
      mesh: {
        position: {
          x: 2,
          y: 0,
          z: 0
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        }
      }
    }
  });
  shaker = new CameraShaker(engine.camera);
  scene.shaker = shaker;
  scene.snapshot = function(tpf) {
    var inUse, item, l, len3, ref3;
    inUse = [];
    ref3 = PoolManager.itemsInUse();
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      item = ref3[l];
      inUse.push(item.toJson());
    }
    return {
      tpf: tpf,
      score: window.score.innerHTML,
      buff: window.buff.innerHTML,
      speed: level.speed,
      pointer: pointer.toJson(),
      player: chicken.toJson(),
      terrain: terrain.toJson(),
      itemsInUse: inUse
    };
  };
  scene.tick = function(tpf) {
    var allEnemies, buff, bullet, enemy, enemyMesh, explosion, found, frame, l, len10, len3, len4, len5, len6, len7, len8, len9, m, n, npcsOnScreen, o, p, q, r, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, t, text;
    chicken.tickOpacity(tpf);
    if (replay.replaying) {
      frame = replay.getFrame();
      chicken.fromJson(frame.player);
      pointer.fromJson(frame.pointer);
      terrain.texture1.offset.y = frame.terrain.offset1;
      terrain.texture2.offset.y = frame.terrain.offset2;
      terrain.setSkin(frame.terrain.background);
      window.score.innerHTML = frame.score;
      window.buff.innerHTML = frame.buff;
      allEnemies = PoolManager.get().getAll();
      npcsOnScreen = PoolManager.itemsInUse();
      ref3 = frame.itemsInUse;
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        enemy = ref3[l];
        enemyMesh = allEnemies.where({
          id: enemy.id
        }).first();
        found = npcsOnScreen.where({
          id: enemy.id
        }).first();
        if (found != null) {
          found.fromJson(enemy);
        } else {
          PoolManager.get().spawnSpecific(enemyMesh);
          enemyMesh.fromJson(enemy);
        }
      }
      results = [];
      for (m = 0, len4 = npcsOnScreen.length; m < len4; m++) {
        enemy = npcsOnScreen[m];
        if (!frame.itemsInUse.where({
          id: enemy.id
        }).any()) {
          results.push(PoolManager.release(enemy, {
            skipExplosion: true
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } else {
      terrain.tick(tpf * level.speed);
      level.tick(tpf * level.speed);
      chicken.tick(tpf * level.speed);
      pointer.tick(tpf);
      ref4 = PoolManager.itemsInUse(Config.enemies);
      for (n = 0, len5 = ref4.length; n < len5; n++) {
        enemy = ref4[n];
        if (enemy == null) {
          continue;
        }
        enemy.tick(tpf * level.speed);
        if (level.running && enemy.collidesWith(chicken)) {
          replay.saveFrame(tpf);
          replay.replay();
          shaker.shakeItLikeAPolaroidPicture();
          explosion = PoolManager.spawn(Explosion);
          explosion.mesh.position.copy(chicken.mesh.position);
        }
      }
      ref5 = PoolManager.itemsInUse(Config.weapons);
      for (o = 0, len6 = ref5.length; o < len6; o++) {
        bullet = ref5[o];
        if (bullet == null) {
          continue;
        }
        bullet.tick(tpf * level.speed);
        ref6 = PoolManager.itemsInUse(Config.enemies);
        for (p = 0, len7 = ref6.length; p < len7; p++) {
          enemy = ref6[p];
          if (enemy == null) {
            continue;
          }
          if (bullet.collidesWith(enemy)) {
            PoolManager.release(bullet);
            if (enemy.invincible != null) {
              continue;
            }
            enemy.health -= 1;
            if (enemy.health <= 0) {
              PoolManager.spawn(Text, {
                text: "+" + (enemy.getPoints()),
                opacity: 1,
                mesh: {
                  position: enemy.mesh.position.clone()
                }
              });
              PoolManager.release(enemy);
              level.addPoints(enemy.getPoints());
            } else {
              explosion = PoolManager.spawn(Explosion);
              explosion.mesh.position.copy(enemy.mesh.position);
            }
          }
        }
      }
      ref7 = PoolManager.itemsInUse(Config.buffs);
      for (q = 0, len8 = ref7.length; q < len8; q++) {
        buff = ref7[q];
        if (buff == null) {
          continue;
        }
        buff.tick(tpf * level.speed);
        if (level.running && chicken.collidesWith(buff)) {
          buff.buffIt();
          PoolManager.spawn(Text, {
            text: "+" + (buff.getPoints()),
            opacity: 1,
            mesh: {
              position: buff.mesh.position.clone()
            }
          });
          Config.createBonus = Helper.addWithMinMax(Config.createBonus, 1, 1, 4);
          PoolManager.release(buff, {
            keepBonus: true
          });
        }
      }
      ref8 = PoolManager.itemsInUse(Text);
      for (r = 0, len9 = ref8.length; r < len9; r++) {
        text = ref8[r];
        if (text != null) {
          text.tick(tpf * level.speed);
        }
      }
      ref9 = PoolManager.itemsInUse(Explosion);
      for (t = 0, len10 = ref9.length; t < len10; t++) {
        explosion = ref9[t];
        if (explosion != null) {
          explosion.tick(tpf * level.speed);
        }
      }
      if (level.running) {
        shootTicker.tick(tpf * level.speed);
        enemyTicker.tick(tpf * level.speed);
        buffTicker.tick(tpf * level.speed);
      }
      return replay.saveFrame(tpf);
    }
  };
  scene.doKeyboardEvent = function(event) {
    if (!level.running) {
      return;
    }
    if (event.type !== 'keyup') {
      return;
    }
    switch (event.which) {
      case 188:
        level.addSpeed(-0.1);
        window.buff.innerHTML = 'speed -';
        return console.ce("decreasing level speed " + level.speed);
      case 190:
        level.addSpeed(0.1);
        window.buff.innerHTML = 'hold on';
        return console.ce("increasing level speed " + level.speed);
      case 75:
        shootTicker.addRate(-0.1);
        window.buff.innerHTML = 'pew pew';
        return console.ce("decreasing fire rate " + shootTicker.amount);
      case 76:
        shootTicker.addRate(0.1);
        window.buff.innerHTML = 'shoot -';
        return console.ce("increasing fire rate " + shootTicker.amount);
      case 72:
        chicken.nextWeapon();
        window.buff.innerHTML = 'yea baby';
        return console.ce("changing weapon " + (chicken.weapons.get().name));
      case 74:
        return console.ce('need more models');
      case 78:
        chicken.addSpeed(-1);
        window.buff.innerHTML = 'move -';
        return console.ce("decreasing movement speed " + chicken.speed);
      case 77:
        chicken.addSpeed(1);
        window.buff.innerHTML = 'woosh';
        return console.ce("increasing movement speed " + chicken.speed);
      case 70:
        enemyTicker.addRate(-0.2);
        window.buff.innerHTML = 'oh noes';
        return console.ce("decreasing enemy rate " + enemyTicker.amount);
      case 71:
        enemyTicker.addRate(0.2);
        window.buff.innerHTML = 'enemies -';
        return console.ce("increasing enemy rate " + enemyTicker.amount);
      case 66:
        window.buff.innerHTML = 'whaa?';
        terrain.setRandomSkin();
        return terrain.addTarget(-0.25);
      default:
        return console.ce(event.which);
    }
  };
  return scene.doMouseEvent = function(event, raycaster) {
    var pos;
    if (replay.replaying) {
      if (event.type === 'mousedown' && replay.canSkipReplay) {
        return level.stop();
      }
    } else {
      if (event.type === 'mousedown' && level.canStartGame && !level.running) {
        level.start();
      }
      if (event.type === 'mousedown') {
        chicken.moving = true;
        pointer.show();
        if (level.running) {
          level.setHighSpeed();
        }
      }
      if (event.type === 'mouseup') {
        chicken.moving = false;
        pointer.hide();
        if (level.running) {
          level.setLowSpeed();
        }
      }
      if (chicken.moving) {
        pos = terrain.getIntersection(raycaster);
        pointer.mesh.position.x = pos.x;
        pointer.mesh.position.y = pos.y;
        pointer.mesh.position.z = pos.z;
        pos.z += 1.5;
        if (level.running) {
          return chicken.setTarget(pos);
        }
      }
    }
  };
});

engine.start();
