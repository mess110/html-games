// Generated by CoffeeScript 1.12.7
var Explosion,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Explosion = (function(superClass) {
  extend(Explosion, superClass);

  function Explosion() {
    var cube, i, j, k, l, m, n;
    this.id = Helper.guid();
    this.cubes = [];
    this.mesh = new THREE.Object3D();
    this.speed = 2;
    this.timeAlive = 0;
    for (i = l = 1; l <= 3; i = ++l) {
      for (j = m = 1; m <= 3; j = ++m) {
        for (k = n = 1; n <= 3; k = ++n) {
          cube = new Box('pink', 0.25);
          this.cubes.push(cube);
          this.mesh.add(cube.mesh);
        }
      }
    }
  }

  Explosion.prototype.tick = function(tpf) {
    var cube, l, len, ref;
    ref = this.cubes;
    for (l = 0, len = ref.length; l < len; l++) {
      cube = ref[l];
      cube.mesh.position.x = Helper.tendTo(cube.mesh.position.x, this.speed * tpf, cube.pos.x);
      cube.mesh.position.y = Helper.tendTo(cube.mesh.position.y, this.speed * tpf, cube.pos.y);
      cube.mesh.position.z = Helper.tendTo(cube.mesh.position.z, this.speed * tpf, cube.pos.z);
      cube.mesh.scale.x -= tpf;
      cube.mesh.scale.y -= tpf;
      cube.mesh.scale.z -= tpf;
    }
    this.timeAlive += tpf;
    if (this.timeAlive > 1) {
      return PoolManager.release(this);
    }
  };

  Explosion.prototype.resetCubes = function() {
    var count, i, j, k, l, len, ref, results;
    count = 0;
    this.timeAlive = 0;
    ref = [-0.33, 0, 0.33];
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      i = ref[l];
      results.push((function() {
        var len1, m, ref1, results1;
        ref1 = [-0.33, 0, 0.33];
        results1 = [];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          j = ref1[m];
          results1.push((function() {
            var len2, n, ref2, results2;
            ref2 = [-0.33, 0, 0.33];
            results2 = [];
            for (n = 0, len2 = ref2.length; n < len2; n++) {
              k = ref2[n];
              this.cubes[count].mesh.position.set(i, j, k);
              this.cubes[count].mesh.scale.set(1, 1, 1);
              this.cubes[count].pos = {
                x: this.cubes[count].mesh.position.x + Helper.random(-1, 1),
                y: this.cubes[count].mesh.position.y + Helper.random(0, 2),
                z: this.cubes[count].mesh.position.z + Helper.random(-1, 1)
              };
              results2.push(count += 1);
            }
            return results2;
          }).call(this));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return Explosion;

})(Box);
