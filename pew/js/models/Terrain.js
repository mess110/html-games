// Generated by CoffeeScript 1.12.7
var BaseTerrain, GridTerrain, Terrain, WrappingTerrain,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BaseTerrain = (function(superClass) {
  extend(BaseTerrain, superClass);

  function BaseTerrain() {
    this.mesh = new THREE.Object3D();
    this.mesh.position.y = -1;
    this.plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  }

  BaseTerrain.prototype.getIntersection = function(raycaster) {
    return raycaster.ray.intersectPlane(this.plane);
  };

  return BaseTerrain;

})(BaseModel);

GridTerrain = (function(superClass) {
  extend(GridTerrain, superClass);

  function GridTerrain() {
    GridTerrain.__super__.constructor.call(this);
    this.size = 20;
    this.step = 30;
    this.color = '#e0e0e0';
    this.grid1 = Helper.grid({
      size: this.size,
      step: this.step,
      color: this.color
    });
    this.grid2 = Helper.grid({
      size: this.size,
      step: this.step,
      color: this.color
    });
    this.grid2.position.z = this.size * 2;
    this.mesh.add(this.grid1);
    this.mesh.add(this.grid2);
  }

  GridTerrain.prototype.tick = function(tpf) {
    var grid, i, len, ref, results;
    ref = [this.grid1, this.grid2];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      grid = ref[i];
      grid.position.z -= tpf;
      if (grid.position.z <= -this.size * 2) {
        results.push(grid.position.z += this.size * 4);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return GridTerrain;

})(BaseTerrain);

WrappingTerrain = (function(superClass) {
  extend(WrappingTerrain, superClass);

  function WrappingTerrain() {
    WrappingTerrain.__super__.constructor.call(this);
    this.grid1 = Helper.plane({
      size: 20,
      map: 'space-1'
    });
    this.grid1.rotation.x = Math.PI / 2;
    this.mesh.add(this.grid1);
    this.setSkin('space-1');
    this.grid2 = Helper.plane({
      size: 20,
      map: 'stars-1'
    });
    this.grid2.position.y = 0.1;
    this.grid2.rotation.x = Math.PI / 2;
    this.grid2.material.transparent = true;
    this.texture2 = this.grid2.material.map;
    this.texture2.wrapT = THREE.RepeatWrapping;
    this.mesh.add(this.grid2);
    this.resetSpeed();
  }

  WrappingTerrain.prototype.setTarget = function(target) {
    return this.target = Helper.addWithMinMax(0, target, 2, 4);
  };

  WrappingTerrain.prototype.addTarget = function(amount) {
    return this.setTarget(this.target + amount);
  };

  WrappingTerrain.prototype.resetSpeed = function() {
    this.speed = Config.defaultTerrainSpeed;
    return this.target = Config.defaultTerrainSpeed;
  };

  WrappingTerrain.prototype.tick = function(tpf) {
    if (this.speed < this.target) {
      this.speed = Helper.addWithMinMax(this.speed, tpf * 10, this.speed, this.target);
    }
    if (this.speed > this.target) {
      this.speed = Helper.addWithMinMax(this.speed, -tpf * 10, this.target, this.speed);
    }
    this.texture1.offset.y += tpf / (this.speed * 2);
    return this.texture2.offset.y += tpf / (this.speed * 3);
  };

  WrappingTerrain.prototype.setSkin = function(key) {
    if (key === this.backgroundSkinKey) {
      return;
    }
    this.backgroundSkinKey = key;
    this.grid1.material.map = TextureManager.get().items[key];
    this.texture1 = this.grid1.material.map;
    return this.texture1.wrapT = THREE.RepeatWrapping;
  };

  WrappingTerrain.prototype.setRandomSkin = function() {
    var arrays;
    arrays = Config.backgrounds.shallowClone();
    if (this.backgroundSkinKey != null) {
      arrays.remove(this.backgroundSkinKey);
    }
    return this.setSkin(arrays.shuffle().first());
  };

  WrappingTerrain.prototype.toJson = function() {
    return {
      background: this.backgroundSkinKey,
      offset1: this.texture1.offset.y,
      offset2: this.texture2.offset.y
    };
  };

  return WrappingTerrain;

})(BaseTerrain);

Terrain = (function(superClass) {
  extend(Terrain, superClass);

  function Terrain() {
    return Terrain.__super__.constructor.apply(this, arguments);
  }

  return Terrain;

})(WrappingTerrain);
