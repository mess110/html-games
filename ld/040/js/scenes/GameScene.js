// Generated by CoffeeScript 1.12.7
var GameScene,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

GameScene = (function(superClass) {
  extend(GameScene, superClass);

  function GameScene() {
    return GameScene.__super__.constructor.apply(this, arguments);
  }

  GameScene.prototype.init = function(options) {
    var camera, engine, i, j, k, l, mole, moleId, nature, plane;
    this.score = 0;
    this.timer = 30;
    this.updateScore();
    window.score.style.visibility = '';
    window.time.style.visibility = '';
    Utils.addCEButton({
      size: '32px',
      padding: '30px',
      position: 'bottom-right'
    });
    Utils.addCEButton({
      size: '32px',
      padding: '30px',
      position: 'bottom-left',
      type: 'reinit'
    });
    camera = LoadingScene.LOADING_OPTIONS.camera;
    camera.position.set(0, 16, 16);
    camera.lookAt(Helper.zero);
    this.tweenMoveTo({
      position: new THREE.Vector3(0, 11, 11)
    }, camera, 4000, TWEEN.Easing.Quartic.Out);
    SoundManager.play('hammer-time');
    engine = Hodler.item('engine');
    engine.setClearColor('#2d882d');
    plane = Helper.plane({
      size: 30,
      color: '#2d882d'
    });
    plane.rotation.x = -Math.PI / 2;
    this.scene.add(plane);
    this.scene.add(Helper.ambientLight());
    this.scene.add(Helper.ambientLight());
    Hodler.item('afterEffects').enable(this.scene, camera);
    this.cooldown = new BaseModel();
    this.cooldown.mesh = this.jmm.clone('hammer');
    this.cooldown.setOpacity(0.5);
    this.cooldown.mesh.position.set(0, -6, 8);
    this.scene.add(this.cooldown.mesh);
    nature = this.jmm.clone('nature');
    this.scene.add(nature);
    this.moles = [];
    moleId = -1;
    for (i = k = 0; k <= 2; i = ++k) {
      for (j = l = 0; l <= 2; j = ++l) {
        moleId += 1;
        mole = new Mole(moleId);
        mole.mesh.position.set(-4 + 4 * i, 0, -4 + 4 * j - 1);
        this.moles.push(mole);
        this.scene.add(mole.mesh);
      }
    }
    this.hammer = new Hammer();
    this.scene.add(this.hammer.mesh);
    return this.setAppearCD(500);
  };

  GameScene.prototype.setAppearCD = function(cd) {
    if (cd == null) {
      cd = 500;
    }
    this.stayTime = cd;
    if (this.popGoesThe != null) {
      clearInterval(this.popGoesThe);
    }
    return this.popGoesThe = setInterval((function(_this) {
      return function() {
        var moles, tMole;
        moles = _this.moles.filter(function(e) {
          return e.hittable === false;
        });
        tMole = moles.shuffle().first();
        if (tMole != null) {
          return tMole.appear();
        }
      };
    })(this), cd);
  };

  GameScene.prototype.uninit = function() {
    window.score.style.visibility = 'hidden';
    window.time.style.visibility = 'hidden';
    clearInterval(this.popGoesThe);
    this.finished = void 0;
    Hodler.item('afterEffects').disable();
    return GameScene.__super__.uninit.call(this);
  };

  GameScene.prototype.updateScore = function() {
    window.score.innerHTML = this.score;
    if (this.score === 10) {
      this.setAppearCD(400);
    }
    if (this.score === 20) {
      return this.setAppearCD(300);
    }
  };

  GameScene.prototype.tick = function(tpf) {
    var k, len, mole, ref, timer;
    this.timer -= tpf;
    if (this.timer < 0) {
      timer = '0.0';
      if (this.finished == null) {
        SoundManager.play('hammer-time');
      }
      this.finished = true;
    } else {
      timer = parseFloat(Math.round(this.timer * 10) / 10).toFixed(1);
    }
    ref = this.moles;
    for (k = 0, len = ref.length; k < len; k++) {
      mole = ref[k];
      mole.stars.rotation.y += 5 * tpf;
    }
    return window.time.innerHTML = timer;
  };

  GameScene.prototype.doKeyboardEvent = function(event) {};

  GameScene.prototype.doMouseEvent = function(event, raycaster) {
    var all, intersections, moles, rumbles;
    if (event.type !== 'mousedown') {
      return;
    }
    if (this.timer > 0) {
      rumbles = this.moles.map(function(e) {
        return e.rumble;
      });
      moles = this.moles.filter(function(e) {
        return e.hittable === true;
      }).map(function(e) {
        return e.mole;
      });
      all = rumbles.concat(moles);
      intersections = raycaster.intersectObjects(all, true);
      if (intersections.any()) {
        return this.hammer.hit(intersections.first());
      }
    }
  };

  return GameScene;

})(BaseScene);
